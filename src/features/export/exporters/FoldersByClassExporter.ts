import JSZip from 'jszip';
import { BaseExporter } from './BaseExporter';
import { Project, AnnotixImage } from '@/lib/db';

/**
 * Folders by Class Exporter
 *
 * Exports images organized in folders by class name.
 * Useful for image classification tasks.
 *
 * Structure:
 * - class1/
 *   - image1.jpg
 *   - image2.jpg
 * - class2/
 *   - image3.jpg
 * - unlabeled/
 *   - image4.jpg
 */
export class FoldersByClassExporter extends BaseExporter {
  async export(
    project: Project,
    images: AnnotixImage[],
    onProgress?: (progress: number) => void
  ): Promise<Blob> {
    const zip = new JSZip();

    // Create folders for each class
    const classFolders = new Map<number, JSZip | null>();
    for (const cls of project.classes) {
      const folderName = this.sanitizeFolderName(cls.name);
      classFolders.set(cls.id, zip.folder(folderName));
    }

    // Create unlabeled folder
    const unlabeledFolder = zip.folder('unlabeled')!;

    // Process each image
    for (let i = 0; i < images.length; i++) {
      const image = images[i];

      // Determine which class(es) this image belongs to
      const classIds = this.getImageClasses(image);

      if (classIds.length === 0) {
        // No annotations - put in unlabeled folder
        unlabeledFolder.file(image.name, image.image);
      } else {
        // Add image to each class folder it belongs to
        for (const classId of classIds) {
          const folder = classFolders.get(classId);
          if (folder) {
            // If image belongs to multiple classes, add suffix to prevent overwrite
            const fileName = classIds.length > 1
              ? this.addClassSuffix(image.name, classId, project)
              : image.name;

            folder.file(fileName, image.image);
          }
        }
      }

      this.updateProgress(i + 1, images.length, onProgress);
    }

    // Add README
    const readmeContent = this.generateReadme(project, images);
    zip.file('README.txt', readmeContent);

    // Generate ZIP blob
    return await zip.generateAsync({ type: 'blob' });
  }

  private getImageClasses(image: AnnotixImage): number[] {
    const classIds = new Set<number>();

    for (const annotation of image.annotations) {
      classIds.add(annotation.classId);
    }

    return Array.from(classIds);
  }

  private sanitizeFolderName(name: string): string {
    // Replace invalid characters for folder names
    return name
      .replace(/[<>:"/\\|?*]/g, '_')
      .replace(/\s+/g, '_')
      .toLowerCase();
  }

  private addClassSuffix(fileName: string, classId: number, project: Project): string {
    const className = project.classes.find((c) => c.id === classId)?.name || `class${classId}`;
    const sanitizedClassName = this.sanitizeFolderName(className);

    const lastDotIndex = fileName.lastIndexOf('.');
    if (lastDotIndex === -1) {
      return `${fileName}_${sanitizedClassName}`;
    }

    const nameWithoutExt = fileName.substring(0, lastDotIndex);
    const ext = fileName.substring(lastDotIndex);
    return `${nameWithoutExt}_${sanitizedClassName}${ext}`;
  }

  private generateReadme(project: Project, images: AnnotixImage[]): string {
    const lines: string[] = [];

    lines.push(`# ${project.name} - Classification Dataset`);
    lines.push('');
    lines.push('## Structure');
    lines.push('');
    lines.push('Images are organized in folders by class:');
    lines.push('');

    // Count images per class
    const classImageCounts = new Map<number, number>();
    let unlabeledCount = 0;

    for (const image of images) {
      const classIds = this.getImageClasses(image);

      if (classIds.length === 0) {
        unlabeledCount++;
      } else {
        for (const classId of classIds) {
          classImageCounts.set(classId, (classImageCounts.get(classId) || 0) + 1);
        }
      }
    }

    // List classes
    for (const cls of project.classes) {
      const count = classImageCounts.get(cls.id) || 0;
      const folderName = this.sanitizeFolderName(cls.name);
      lines.push(`- ${folderName}/ (${count} images)`);
    }

    if (unlabeledCount > 0) {
      lines.push(`- unlabeled/ (${unlabeledCount} images)`);
    }

    lines.push('');
    lines.push('## Statistics');
    lines.push('');
    lines.push(`Total images: ${images.length}`);
    lines.push(`Total classes: ${project.classes.length}`);
    lines.push('');

    lines.push('## Class Distribution');
    lines.push('');
    for (const cls of project.classes) {
      const count = classImageCounts.get(cls.id) || 0;
      const percentage = images.length > 0 ? ((count / images.length) * 100).toFixed(1) : '0.0';
      lines.push(`${cls.name}: ${count} images (${percentage}%)`);
    }

    lines.push('');
    lines.push('---');
    lines.push('Generated by Annotix - TecMedHub FabLab');
    lines.push(`Export Date: ${new Date().toISOString()}`);

    return lines.join('\n');
  }
}
