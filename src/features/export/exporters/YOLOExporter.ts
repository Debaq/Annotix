import JSZip from 'jszip';
import { BaseExporter } from './BaseExporter';
import { Project, AnnotixImage, Annotation } from '@/lib/db';
import { normalizeCoordinates } from '../utils/converters';
import { skeletonPresets } from '@/features/canvas/data/skeletonPresets';

export class YOLOExporter extends BaseExporter {
  constructor(private includeSegmentation: boolean = false) {
    super();
  }

  async export(
    project: Project,
    images: AnnotixImage[],
    onProgress?: (progress: number) => void
  ): Promise<Blob> {
    const zip = new JSZip();

    // Create folder structure
    const imagesFolder = zip.folder('images')!;
    const labelsFolder = zip.folder('labels')!;

    // Add classes.txt
    const classesContent = project.classes.map((c) => c.name).join('\n');
    zip.file('classes.txt', classesContent);

    // Add data.yaml
    const yamlContent = this.generateDataYaml(project);
    zip.file('data.yaml', yamlContent);

    // Process each image
    for (let i = 0; i < images.length; i++) {
      const image = images[i];

      // Add image file
      imagesFolder.file(image.name, image.image);

      // Generate label file
      const labelContent = this.generateLabelFile(image, project);
      const labelName = image.name.replace(/\.[^/.]+$/, '.txt');
      labelsFolder.file(labelName, labelContent);

      this.updateProgress(i + 1, images.length, onProgress);
    }

    // Generate ZIP blob
    return await zip.generateAsync({ type: 'blob' });
  }

  private generateDataYaml(project: Project): string {
    const lines = [
      `# YOLO Dataset Configuration`,
      `# Generated by Annotix`,
      ``,
      `path: .`,
      `train: images`,
      `val: images`,
      ``,
      `nc: ${project.classes.length}`,
      `names:`,
    ];

    project.classes.forEach((cls) => {
      lines.push(`  ${cls.id}: ${cls.name}`);
    });

    // Add keypoints configuration if project type is keypoints
    if (project.type === 'keypoints') {
      lines.push('');
      lines.push('# Keypoints configuration');

      // Use COCO-17 as default skeleton
      const skeleton = skeletonPresets['coco-17'];
      if (skeleton) {
        lines.push(`kpt_shape: [${skeleton.points.length}, 3]  # number of keypoints, number of dims (x, y, visibility)`);
        lines.push('');
        lines.push('# Keypoint names');
        lines.push('keypoint_names:');
        skeleton.points.forEach((name: string, idx: number) => {
          lines.push(`  ${idx}: ${name}`);
        });

        lines.push('');
        lines.push('# Skeleton connections (for visualization)');
        lines.push('skeleton:');
        skeleton.connections.forEach((conn: [number, number]) => {
          lines.push(`  - [${conn[0]}, ${conn[1]}]`);
        });
      }
    }

    return lines.join('\n');
  }

  private generateLabelFile(image: AnnotixImage, project: Project): string {
    const lines: string[] = [];

    image.annotations.forEach((annotation) => {
      if (annotation.type === 'bbox') {
        const line = this.formatBBoxAnnotation(annotation, image.width, image.height);
        if (line) lines.push(line);
      } else if (annotation.type === 'mask' && this.includeSegmentation) {
        // TODO: Implement mask to polygon conversion
        // For now, skip mask annotations
      }
    });

    return lines.join('\n');
  }

  private formatBBoxAnnotation(
    annotation: Annotation,
    imageWidth: number,
    imageHeight: number
  ): string | null {
    const { x, y, width, height } = annotation.data as {
      x: number;
      y: number;
      width: number;
      height: number;
    };

    // Normalize coordinates
    const normalized = normalizeCoordinates(
      { x, y, width, height },
      imageWidth,
      imageHeight
    );

    // YOLO format: <class_id> <x_center> <y_center> <width> <height>
    const xCenter = normalized.x + normalized.width / 2;
    const yCenter = normalized.y + normalized.height / 2;

    return `${annotation.classId} ${xCenter.toFixed(6)} ${yCenter.toFixed(6)} ${normalized.width.toFixed(6)} ${normalized.height.toFixed(6)}`;
  }
}
